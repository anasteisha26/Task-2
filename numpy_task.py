# -*- coding: utf-8 -*-
"""Numpy_task.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GHUnUB_0bVJwYYNEmZTxZojINuTNOgvg
"""

import numpy as np

# 1. Дан случайный массив, поменять знак у элементов, значения которых между 3 и 8

random_array = np.random.randint(0,50, size=(10, 10))
random_array

np.where((3 < random_array) & (random_array < 8), -1*random_array, random_array)

# 2. Заменить максимальный элемент случайного массива на 0

max_index = np.unravel_index(np.argmax(random_array), random_array.shape)
random_array[max_index] = 0
random_array

# 3. Построить прямое произведение массивов (все комбинации с каждым элементом). На вход подается двумерный массив.
array_2d = np.array([[1, 2, 3, 4, 5],
                     [6, 7, 8, 9, 10]])

# Compute the Cartesian product
cartesian_product = np.transpose([np.tile(array_2d[0], len(array_2d[1])),
                                  np.repeat(array_2d[1], len(array_2d[0]))])

print("Cartesian Product:")
print(cartesian_product)

# 4. Даны 2 массива A (8x3) и B (2x2). Найти строки в A, которые содержат
# элементы из каждой строки в B, независимо от порядка элементов в B

A = np.random.randint(0, 6, size=(8, 3))
B = np.random.randint(0, 6, size=(2, 2))
print(A)
print()
print()
print(B)
print()

for row in A:
    if np.all(np.isin(row, B)):
        print(f"Строки A, элементы которых полностью есть в B:")
        print(row)

# 5. Дана 10x3 матрица, найти строки из неравных значений
# (например строка [2,2,3] остается, строка [3,3,3] удаляется)

fifth_matrix = np.random.randint(0,3, size=(10, 3))
print("Given matrix:")
print(fifth_matrix)


def all_elements_same(array):
    # Convert the list of arrays to a 2D Numpy array
    arr = np.array(array)

    # Check if all elements in each row are equal to the first element
    return (arr == arr[:, 0, None]).all(axis=1)

result = all_elements_same(fifth_matrix)
print()
print("Rows with not equal elements:")
for row_idx, is_same in enumerate(result):
    if not is_same:
        print(f"Row {row_idx}: {fifth_matrix[row_idx]}")

print()

print("Rows with the same elements, that were deleted:")
for row_idx, is_same in enumerate(result):
    if is_same:
        print(f"Row {row_idx}: {fifth_matrix[row_idx]}")

# 6. Дан двумерный массив. Удалить те строки, которые повторяются.

sixth_arr = np.random.randint(0,4, size=(20, 3))
print("The initial 2-d array:")
print()
print(sixth_arr)
print()
print(f"The amount of rows:", sixth_arr.shape[0])

print()
print()
print("The array with only unique values:")
unique_rows = np.unique(sixth_arr, axis = 0)
print(unique_rows)
print()
print(f"The amount of rows:", unique_rows.shape[0])
print()
print(f"{sixth_arr.shape[0]-unique_rows.shape[0]} rows were not unique and, therefore, deleted.")

#######################################################################################
# Tasks pure Python v.s. Numpy

# Задача 1. Подсчитать произведение ненулевых элементов на диагонали прямоугольной матрицы.
# Например, для X = np.array([ [1, 0, 1],
#                              [2, 0, 2],
#                              [3, 0, 3],
#                              [4, 4, 4]]) ответ 3.

# Numpy solution

rand_array = np.random.randint(0,7, size=(4, 6))
print(rand_array)

print()
not_null_values_multiplicated = 1
diagonal_values = np.diagonal(rand_array)
print(f"The values on a diagonal: {diagonal_values}")
for value in diagonal_values:
  if value != 0:
    not_null_values_multiplicated = not_null_values_multiplicated * value
print(f"The product of these values: {not_null_values_multiplicated}")

# Pure Python solution

from random import randint

print("The given matrix:")
matrix=[]
for i in range(4):
    line=[]
    for j in range(6):
        line.append(randint(0,5))
    matrix.append(line)
for line in matrix:
  print(line)

print()
print("The diagonal values:")
product=1
for i in range(5):
    for j in range(3):
        if i==j and matrix[i][j]!=0:
          print(matrix[i][j])
          product=product*matrix[i][j]

print()
print(f"The product of diagonal values is: {product}")

# Задача 2: Даны два вектора x и y. Проверить, задают ли они одно и то же мультимножество.
# Например, для x = np.array([1, 2, 2, 4]), y = np.array([4, 2, 1, 2]) ответ True.

# Numpy solution

x=np.random.randint(0,3,5)
print(x)
y=np.random.randint(0,3,5)
print(y)

if np.array_equal(np.sort(x), np.sort(y)):
    print("The arrays create the same multiset.")
else:
    print("The arrays do not create the same multiset.")

# Python solution
import random

listik =[]

for i in range(5):
  random_int = random.randint(0, 3)
  listik.append(random_int)
print(listik)

listochek =[]

for i in range(5):
  random_int = random.randint(0, 3)
  listochek.append(random_int)
print(listochek)

are_equal_sorted = sorted(listik) == sorted(listochek)
if are_equal_sorted:
    print("The lists have the same elements.")
else:
    print("The lists do not have the same elements.")

# Задача 3: Найти максимальный элемент в векторе x среди элементов,
# перед которыми стоит ноль. Например, для x = np.array([6, 2, 0, 3, 0, 0, 5, 7, 0]) ответ 5.

#Python solution:
import random
x = []
for i in range (20):
    x.append(random.randint(0,4))
print(x)
print()

try:
  list_before_null = []
  for i, element in enumerate(x):
      if i > 0 and x[i - 1] == 0:
          list_before_null.append(element)
except:
  print("There is no zeros in array.")


print("The list of values that have 0 before them:")
print(list_before_null)
print()
print("The biggest value out of them:")
print(max(list_before_null))

# Numpy solution

random_arry =np.random.randint(0,7,15)
print(random_arry)

values_after_zero = []

for i in range(len(random_arry) - 1):
    if random_arry[i] == 0:
        values_after_zero.append(random_arry[i + 1])

try:
    print("The largest value immediately after 0 is:", max(values_after_zero))
except:
    print("No values found immediately after 0.")

# Задача 4: Реализовать кодирование длин серий (Run-length encoding).
# Для некоторого вектора x необходимо вернуть кортеж из двух векторов одинаковой длины.
# Первый содержит числа, а второй - сколько раз их нужно повторить.
# Например, для x = np.array([2, 2, 2, 3, 3, 3, 5]) ответ (np.array([2, 3, 5]), np.array([3, 3, 1])).

# Python solution:
def run_length_encode(arr):
    values = []
    lengths = []
    current_value = arr[0]
    current_length = 1

    for i in range(1, len(arr)):
        if arr[i] == current_value:
            current_length += 1
        else:
            values.append(current_value)
            lengths.append(current_length)

            current_value = arr[i]
            current_length = 1

    values.append(current_value)
    lengths.append(current_length)

    values = np.array(values)
    lengths = np.array(lengths)

    return values, lengths

arr =np.random.randint(0,4,15)
print("Given array:", arr)
print()

encoded_values, run_lengths = run_length_encode(arr)
returned_list = (encoded_values, run_lengths)

print(returned_list)

# Numpy solution:

def run_length_encoding(arr):
    diff = np.concatenate(([True], arr[1:] != arr[:-1], [True]))
    idx = np.flatnonzero(diff)

    lengths = np.diff(idx)

    values = arr[idx[:-1]]

    return values, lengths

arr =np.random.randint(0,4,15)
print(arr)
values, lengths = run_length_encoding(arr)
print("Values:", values)
print("Lengths:", lengths)

# Задача 5: Даны две выборки объектов - X и Y. Вычислить матрицу евклидовых расстояний между объектами.
# Сравните с функцией scipy.spatial.distance.cdist по скорости работы.

# Numpy solution

from scipy.spatial import distance

X = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
Y = np.array([[2, 4, 6], [1, 3, 5]])

# Calculate Euclidean distance using NumPy
distance_matrix = np.linalg.norm(X[:, np.newaxis] - Y, axis=2)

print("Euclidean distance matrix:")
print(distance_matrix)

# Compare with scipy.spatial.distance.cdist
scipy_distance_matrix = distance.cdist(X, Y, metric='euclidean')

print("\nScipy distance matrix:")
print(scipy_distance_matrix)

# Python solution
def euclidean_distance(a, b):
    assert len(a) == len(b), "Input vectors must have the same length"

    squared_diffs = [(x - y) ** 2 for x, y in zip(a, b)]

    distance = sum(squared_diffs) ** 0.5

    return distance

X = [(1, 2, 3), (4, 5, 6), (7, 8, 9)]
Y = [(2, 4, 6), (1, 3, 5)]

distance_matrix = []

for x in X:
    row_distances = [euclidean_distance(x, y) for y in Y]
    distance_matrix.append(row_distances)

for row in distance_matrix:
    print(row)

##################################################################################

# Задача 6.

# 1. Просмотрите файл cereal.csv. Этот файл содержит количества калорий
# для различных марок хлопьев. Загрузите данные из файла и сохраните их как calorie_stats.


calorie_stats = np.loadtxt("/content/cereal.csv", delimiter=",")
calorie_stats

# 2. В одной порции CrunchieMunchies содержится 60 калорий.
# Насколько выше среднее количество калорий у ваших конкурентов?
# Сохраните ответ в переменной average_calories и распечатайте переменную в терминале.

average_calories = np.round(np.average(calorie_stats))
print("The average amount of calories of competitors' products is:", average_calories)
print("It is, on average,",average_calories - 60,"calories, or,", np.round(100*(47/60)),"% higher.")

# 3. Корректно ли среднее количество калорий отражает распределение набора данных?
# Давайте отсортируем данные и посмотрим.
# Отсортируйте данные и сохраните результат в переменной calorie_stats_sorted.
# Распечатайте отсортированную информацию.

calorie_stats_sorted = np.sort(calorie_stats)
print("Sorted data:")
print()
calorie_stats_sorted

# 4. Похоже, что большинство значений выше среднего. Давайте посмотрим,
# является ли медиана наиболее корректным показателем набора данных.
# Вычислите медиану набора данных и сохраните свой ответ в median_calories.
# Выведите медиану, чтобы вы могли видеть, как она сравнивается со средним значением.

median_calories = np.median(calorie_stats)
print("Median:",median_calories)
print("Mean:",average_calories)

print()
print(calorie_stats_sorted)
print()
print("Yes, median seems to reflect the tendency more correctly.")

# 5. В то время как медиана показывает, что по крайней мере половина
# наших значений составляет более 100 калорий, было бы более впечатляюще показать,
# что значительная часть конкурентов имеет более высокое количество калорий, чем CrunchieMunchies.
# Рассчитайте различные процентили и распечатайте их, пока не найдете наименьший процентиль,
# превышающий 60 калорий. Сохраните это значение в переменной nth_percentile.

print("Percentile - 50. Calories:", np.percentile(calorie_stats, 50))
print("Percentile - 40. Calories:", np.percentile(calorie_stats, 40))
print("Percentile - 20. Calories:", np.percentile(calorie_stats, 20))
print("Percentile - 15. Calories:", np.percentile(calorie_stats, 15))
print("Percentile - 10. Calories:", np.percentile(calorie_stats, 10))
print("Percentile - 7. Calories:", np.percentile(calorie_stats, 7))
print("Percentile - 4. Calories:", np.percentile(calorie_stats, 4))
print("Percentile - 3. Calories:", np.percentile(calorie_stats, 3))
print()
print("The lowest percentile, whose value is > 60 calories, is 4.")

# 6. Хотя процентиль показывает нам, что у большинства конкурентов количество калорий намного выше,
# это неудобная концепция для использования в маркетинговых материалах.
# Вместо этого давайте подсчитаем процент хлопьев, в которых содержится более 60 калорий на порцию.
# Сохраните свой ответ в переменной more_calories и распечатайте его

more_than_sixty = 100 - 4
print(f"Only 4% of competitors have as little calories as our product. \
And {more_than_sixty}% of competitors have more calories than we do.")

# 7. Это действительно высокий процент. Это будет очень полезно, когда мы будем продвигать CrunchieMunchies.
# Но один вопрос заключается в том, насколько велики различия в наборе данных?
# Можем ли мы сделать обобщение, что в большинстве злаков содержится около 100 калорий или разброс еще больше?
# Рассчитайте величину отклонения, найдя стандартное отклонение,
# Сохраните свой ответ в calorie_std и распечатайте на терминале. Как мы можем включить эту ценность в наш анализ?

std = np.std(calorie_stats)
our_deviation = (110-60)/19
print(f"The standard deviation is {std}.")
print()
print(f"It means that the majority has the range of calories from 90 to 130. But our product is {our_deviation} deviations below the average!")

# 8. Напишите короткий абзац, в котором кратко изложите свои выводы и то, как,
# по вашему мнению, эти данные могут быть использованы в интересах Mycrunch
# при маркетинге CrunchieMunchies.


# Практически никто на рынке не может сравниться с CrunchieMunchies по такой низкокалорийности!
# Производитель входит в 4 % самых низкокалорийных производителей. Калорийность их продукта - сильно ниже среднего.
# Это отличный point для рекламы.